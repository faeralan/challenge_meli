import { Injectable, NotFoundException, ForbiddenException, Inject, BadRequestException } from '@nestjs/common';
import { CreateProductDto } from './dto/create-product.dto';
import { UpdateProductDto } from './dto/update-product.dto';
import { ProductDetailDto } from './dto/product-detail.dto';
import { SellerInfoDto } from '../users/dto/seller-info.dto';
import { Product } from './entities/product.entity';
import { User } from '../users/entities/user.entity';
import { UsersService } from '../users/users.service';
import { IProductRepository } from './repositories/product.repository.interface';
import { PAYMENT_METHODS } from './constants/payment-methods.constant';
import { ConfigService } from '@nestjs/config';

@Injectable()
export class ProductsService {
  constructor(
    @Inject('IProductRepository')
    private readonly productRepository: IProductRepository,
    private readonly usersService: UsersService,
    private readonly configService: ConfigService
  ) {}

  private generateSlug(title: string): string {
    return title
      .toLowerCase()
      .normalize('NFD') // Normalize to decomposed form
      .replace(/[\u0300-\u036f]/g, '') // Remove diacritics
      .replace(/[^a-z0-9\s-]/g, '') // Remove special characters
      .trim()
      .replace(/\s+/g, '-') // Replace spaces with hyphens
      .replace(/-+/g, '-'); // Replace multiple hyphens with single
  }

  private processUploadedFiles(files: Express.Multer.File[]): { images: string[]; mainImage: string } {
    if (!files || files.length === 0) {
      throw new BadRequestException('Files not valid');
    }

    const port = this.configService.get('PORT') || '3000';
    const baseUrl = this.configService.get('API_BASE_URL') || `http://localhost:${port}`;
    const imageUrls = files.map(file => `${baseUrl}/uploads/temp/${file.filename}`);
    
    return {
      images: imageUrls,
      mainImage: imageUrls[0], // First image as main image
    };
  }

  // Methods to map the user to the seller info
  private mapUserToSellerInfo(user: User): SellerInfoDto {
    return {
      id: user.id,
      name: user.name,
      reputation: user.reputation,
      location: user.location,
      salesCount: user.salesCount,
      joinDate: user.joinDate,
      isVerified: user.isVerified,
    };
  }

  private mapToProductDetail(product: Product): ProductDetailDto {
    // Filter only enabled payment methods for this product
    const availablePaymentMethods = PAYMENT_METHODS.filter(
      method => product.enabledPaymentMethods.includes(method.id)
    );

    return {
      ...product,
      seller: this.mapUserToSellerInfo(product.seller),
      paymentMethods: availablePaymentMethods
    };
  }

  async create(
    createProductDto: CreateProductDto, 
    user: User, 
    files?: Express.Multer.File[]
  ): Promise<Product> {
    // Generate slug if not provided
    const baseSlug = createProductDto.slug || this.generateSlug(createProductDto.title);

    let images: string[];
    let mainImage: string;

    // If files are provided, process them. Otherwise, use the images from the DTO
    if (files && files.length > 0) {
      const processedFiles = this.processUploadedFiles(files);
      images = processedFiles.images;
      mainImage = processedFiles.mainImage;
    } else if (createProductDto.images && createProductDto.images.length > 0) {
      images = createProductDto.images;
      mainImage = createProductDto.mainImage || createProductDto.images[0];
    } else {
      throw new BadRequestException(
        'You must provide at least one image, either by uploading files or providing URLs'
      );
    }

    const newProduct: Product = {
      ...createProductDto,
      id: 'TEMP_ID', // Temporary ID (will be auto-generated by repository)
      seller: user,
      slug: baseSlug,
      images,
      mainImage,
      createdAt: new Date(),
      updatedAt: new Date(),
    };

    const savedProduct = await this.productRepository.create(newProduct);
    
    // Increment salesCount of the seller
    await this.usersService.incrementSalesCount(user.id);
    
    return savedProduct;
  }

  async findAll(): Promise<ProductDetailDto[]> {
    const products = await this.productRepository.findAll();
    return products.map(product => this.mapToProductDetail(product));
  }

  async findOne(identifier: string): Promise<ProductDetailDto> {
    const product = await this.productRepository.findByIdOrSlug(identifier);
    
    if (!product) {
      throw new NotFoundException(`Product with identifier '${identifier}' not found`);
    }

    return this.mapToProductDetail(product);
  }

  async update(id: string, updateProductDto: UpdateProductDto): Promise<Product> {
    const existingProduct = await this.productRepository.findById(id);
    
    if (!existingProduct) {
      throw new NotFoundException(`Product with ID ${id} not found`);
    }

    // Handle slug generation if title is being updated
    const updates: Partial<Product> = { ...updateProductDto };
    
    if (updateProductDto.title && updateProductDto.title !== existingProduct.title) {
      const baseSlug = updateProductDto.slug || this.generateSlug(updateProductDto.title);
      updates.slug = baseSlug; // Repository will handle uniqueness
    } else if (updateProductDto.slug) {
      updates.slug = updateProductDto.slug; // Repository will handle uniqueness
    }

    return await this.productRepository.update(id, updates);
  }

  async remove(id: string, userId: string): Promise<void> {
    const product = await this.productRepository.findById(id);
    
    if (!product) {
      throw new NotFoundException(`Product with ID ${id} not found`);
    }

    // Verify that the user is the owner of the product
    if (product.seller.id !== userId) {
      throw new ForbiddenException('You are not authorized to delete this product. Only the owner can delete it.');
    }

    const deleted = await this.productRepository.delete(id);
    
    if (!deleted) {
      throw new NotFoundException(`Product with ID ${id} not found`);
    }
  }

  getAvailablePaymentMethods() {
    return PAYMENT_METHODS;
  }
}
