import { Injectable, NotFoundException, ForbiddenException, Inject } from '@nestjs/common';
import { CreateProductDto } from './dto/create-product.dto';
import { UpdateProductDto } from './dto/update-product.dto';
import { ProductDetailDto } from './dto/product-detail.dto';
import { SellerInfoDto } from '../users/dto/seller-info.dto';
import { Product } from './entities/product.entity';
import { User } from '../users/entities/user.entity';
import { UsersService } from '../users/users.service';
import { IProductRepository } from './repositories/product.repository.interface';
import { PAYMENT_METHODS } from './constants/payment-methods.constant';

@Injectable()
export class ProductsService {
  constructor(
    @Inject('IProductRepository')
    private readonly productRepository: IProductRepository,
    private readonly usersService: UsersService
  ) {}

  private generateSlug(title: string): string {
    return title
      .toLowerCase()
      .normalize('NFD') // Normalize to decomposed form
      .replace(/[\u0300-\u036f]/g, '') // Remove diacritics
      .replace(/[^a-z0-9\s-]/g, '') // Remove special characters
      .trim()
      .replace(/\s+/g, '-') // Replace spaces with hyphens
      .replace(/-+/g, '-'); // Replace multiple hyphens with single
  }

  // Methods to map the user to the seller info
  private mapUserToSellerInfo(user: User): SellerInfoDto {
    return {
      id: user.id,
      name: user.name,
      reputation: user.reputation,
      location: user.location,
      salesCount: user.salesCount,
      joinDate: user.joinDate,
      isVerified: user.isVerified,
    };
  }

  private mapToProductDetail(product: Product): ProductDetailDto {
    // Filter only enabled payment methods for this product
    const availablePaymentMethods = PAYMENT_METHODS.filter(
      method => product.enabledPaymentMethods.includes(method.id)
    );

    return {
      ...product,
      seller: this.mapUserToSellerInfo(product.seller),
      paymentMethods: availablePaymentMethods
    };
  }

  async create(createProductDto: CreateProductDto, user: User): Promise<Product> {
    // Generate slug if not provided
    const baseSlug = createProductDto.slug || this.generateSlug(createProductDto.title);

    const newProduct: Product = {
      ...createProductDto,
      id: 'TEMP_ID', // Temporary ID (will be auto-generated by repository)
      seller: user,
      slug: baseSlug,
      createdAt: new Date(),
      updatedAt: new Date(),
    };

    const savedProduct = await this.productRepository.create(newProduct);
    
    // Increment salesCount of the seller
    await this.usersService.incrementSalesCount(user.id);
    
    return savedProduct;
  }

  async findAll(): Promise<ProductDetailDto[]> {
    const products = await this.productRepository.findAll();
    return products.map(product => this.mapToProductDetail(product));
  }

  async findOne(identifier: string): Promise<ProductDetailDto> {
    const product = await this.productRepository.findByIdOrSlug(identifier);
    
    if (!product) {
      throw new NotFoundException(`Product with ID or slug '${identifier}' not found`);
    }

    return this.mapToProductDetail(product);
  }

  async findBySlug(slug: string): Promise<ProductDetailDto> {
    const product = await this.productRepository.findBySlug(slug);
    
    if (!product) {
      throw new NotFoundException(`Product with slug '${slug}' not found`);
    }

    return this.mapToProductDetail(product);
  }

  async update(id: string, updateProductDto: UpdateProductDto): Promise<Product> {
    const existingProduct = await this.productRepository.findById(id);
    
    if (!existingProduct) {
      throw new NotFoundException(`Product with ID ${id} not found`);
    }

    // Handle slug generation if title is being updated
    const updates: Partial<Product> = { ...updateProductDto };
    
    if (updateProductDto.title && updateProductDto.title !== existingProduct.title) {
      const baseSlug = updateProductDto.slug || this.generateSlug(updateProductDto.title);
      updates.slug = baseSlug; // Repository will handle uniqueness
    } else if (updateProductDto.slug) {
      updates.slug = updateProductDto.slug; // Repository will handle uniqueness
    }

    return await this.productRepository.update(id, updates);
  }

  async remove(id: string, userId: string): Promise<void> {
    const product = await this.productRepository.findById(id);
    
    if (!product) {
      throw new NotFoundException(`Product with ID ${id} not found`);
    }

    // Verify that the user is the owner of the product
    if (product.seller.id !== userId) {
      throw new ForbiddenException('You are not authorized to delete this product. Only the owner can delete it.');
    }

    const deleted = await this.productRepository.delete(id);
    
    if (!deleted) {
      throw new NotFoundException(`Product with ID ${id} not found`);
    }
  }

  getAvailablePaymentMethods() {
    return PAYMENT_METHODS;
  }
}
